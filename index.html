<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sankey Overview</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      --bg: #f5f6fb;
      --panel: #ffffff;
      --border: #e5e7eb;
      --text: #111827;
      --muted: #6b7280;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    header { padding: 6px 24px 0; }
    h1 { margin: 0; font-size: 22px; letter-spacing: -0.02em; }
    p { margin: 0; color: var(--muted); font-size: 14px; }
    .controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 2px 24px 4px;
    }
    .controls-left {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .controls-row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      width: 100%;
    }
    .controls-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
    .btn {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 10px;
    }
    .date-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .date-input {
      width: 140px;
      padding: 4px 6px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 12px;
    }
    .status { color: var(--muted); font-size: 13px; }
    #chart {
      width: 95vw;
      max-width: 1400px;
      height: 95vh;
      max-height: 900px;
      min-height: 520px;
      margin: 0 auto 16px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0 10px 10px;
      box-shadow: 0 10px 32px rgba(15,23,42,0.08);
      position: relative;
      overflow: auto;
    }
    svg { width: 100%; height: 100%; }
    .node rect { fill-opacity: 0.9; stroke: rgba(0,0,0,0.08); stroke-width: 1; rx: 4; }
    .node text { fill: #0f172a; font-size: 10px; pointer-events: none; }
    .link { fill: none; stroke-opacity: 0.35; }
    .tooltip {
      position: absolute;
      background: rgba(255,255,255,0.98);
      color: #0f172a;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.4;
      pointer-events: none;
      border: 1px solid #e5e7eb;
      box-shadow: 0 10px 32px rgba(15, 23, 42, 0.16);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 0.12s ease, transform 0.12s ease;
      white-space: pre-line;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 20;
    }
    .modal {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.18);
      width: min(1100px, 96vw);
      height: min(85vh, 720px);
      max-width: 96vw;
      max-height: 90vh;
      min-width: 640px;
      min-height: 360px;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      border: 1px solid #e5e7eb;
      overflow: hidden;
      resize: both;
    }
    .modal-resizer {
      position: absolute;
      right: 4px;
      bottom: 4px;
      width: 18px;
      height: 18px;
      cursor: se-resize;
      z-index: 2;
      touch-action: none;
      background: linear-gradient(135deg, transparent 60%, #cbd5e1 60%, #cbd5e1 70%, transparent 70%, transparent 80%, #cbd5e1 80%, #cbd5e1 90%, transparent 90%);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 18px 12px;
      border-bottom: 1px solid #e5e7eb;
      gap: 12px;
      cursor: move;
    }
    .modal-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }
    .modal-subtitle {
      margin: 4px 0 0;
      color: #6b7280;
      font-size: 13px;
    }
    .modal-close {
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      width: 36px;
      height: 36px;
      cursor: pointer;
      font-size: 18px;
      color: #111827;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      padding: 12px 18px;
      gap: 10px;
      border-bottom: 1px solid #e5e7eb;
    }
    .modal-table-wrap {
      overflow-x: scroll;
      overflow-y: scroll;
      scrollbar-gutter: stable both-edges;
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 #f3f4f6;
      padding: 4px 18px 18px;
      flex: 1 1 auto;
      min-height: 0;
    }
    .modal-table-wrap::-webkit-scrollbar {
      width: 12px !important;
      height: 15px !important;
    }
    .modal-table-wrap::-webkit-scrollbar:horizontal {
      height: 15px !important;
    }
    .modal-table-wrap::-webkit-scrollbar-track {
      background: #f3f4f6;
    }
    .modal-table-wrap::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 999px;
      border: 3px solid #f3f4f6;
    }
    .modal-table-wrap::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    table.modal-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    table.modal-table thead {
      position: sticky;
      top: 0;
      background: #f9fafb;
      z-index: 1;
    }
    table.modal-table th,
    table.modal-table td {
      text-align: left;
      padding: 4px 6px;
      border-bottom: 1px solid #e5e7eb;
      white-space: nowrap;
    }
    table.modal-table td.category {
      white-space: normal;
    }
    table.modal-table th:first-child,
    table.modal-table td:first-child {
      width: 64px;
    }
    table.modal-table th:last-child,
    table.modal-table td:last-child {
      text-align: right;
    }
    table.modal-table th.sortable {
      cursor: pointer;
      user-select: none;
    }
    table.modal-table th.sortable:hover {
      background: #eef2f7;
    }
    .modal-empty {
      padding: 12px 0;
      color: #9ca3af;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <header>
    <h1 id="title">Sankey Overview - quicken_export.xlsx</h1>
  </header>
  <div class="controls">
    <div class="controls-left">
      <div class="controls-row">
        <label class="btn">
          Load another file
          <input id="file-input" type="file" accept=".xlsx" style="display:none">
        </label>
        <span class="status" id="status">Loading quicken_export.xlsx...</span>
        <label class="status" style="display:flex;align-items:center;gap:6px;">
          Min threshold $
          <input id="min-viz" type="number" min="0" step="100" value="5000" style="width:90px;padding:4px 6px;border:1px solid #d1d5db;border-radius:8px;font-size:12px;">
        </label>
        <label class="status" style="display:flex;align-items:center;gap:6px;">
          Font size
          <input id="font-size" type="number" min="6" max="32" step="1" value="10" style="width:72px;padding:4px 6px;border:1px solid #d1d5db;border-radius:8px;font-size:12px;">
        </label>
        <div class="date-controls" id="date-controls" style="display:none;">
          <label class="status" style="display:flex;align-items:center;gap:6px;">
            Min date
            <input id="min-date" type="date" class="date-input">
          </label>
          <label class="status" style="display:flex;align-items:center;gap:6px;">
            Max date
            <input id="max-date" type="date" class="date-input">
          </label>
        </div>
        <label id="date-range-wrapper" class="status" style="display:none;align-items:center;gap:6px;">
          Date range
          <select id="date-range" style="padding:6px;border:1px solid #d1d5db;border-radius:8px;font-size:12px;">
            <option value="all" selected>All</option>
            <option value="custom" id="date-range-custom" hidden>Custom</option>
            <option value="ytd">YTD</option>
            <option value="cy-1" id="date-range-cy-1">CY</option>
            <option value="cy-2" id="date-range-cy-2">CY</option>
            <option value="cy-3" id="date-range-cy-3">CY</option>
            <option value="rolling-12mo">Rolling 12mo</option>
            <option value="rolling-24mo">Rolling 24mo</option>
            <option value="rolling-36mo">Rolling 36mo</option>
          </select>
        </label>
      </div>
      <div class="controls-row">
        <label class="status" style="display:flex;align-items:center;gap:6px;">
          Export
          <select id="export-format" style="padding:6px;border:1px solid #d1d5db;border-radius:8px;font-size:12px;">
            <option value="png">PNG</option>
            <option value="svg">SVG</option>
          </select>
        </label>
        <button id="export-btn" class="btn" type="button" style="font-size:12px;">Save chart</button>
        <button id="reset-suppressed" class="btn" type="button" style="font-size:12px;">Reset suppressed rows</button>
      </div>
    </div>
  </div>
  <div id="chart">
    <div id="placeholder" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9ca3af;font-size:14px;text-align:center;padding:16px;">Preparing chart...</div>
    <div class="tooltip" id="tooltip"></div>
  </div>

  <div class="modal-backdrop" id="details-backdrop">
    <div class="modal">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="modal-title">Category details</div>
          <div class="modal-subtitle" id="modal-subtitle"></div>
        </div>
        <button class="modal-close" id="modal-close" aria-label="Close details">&times;</button>
      </div>
      <div class="modal-actions">
        <button class="btn" id="download-rows" type="button">Download rows (CSV)</button>
      </div>
      <div class="modal-table-wrap">
        <table class="modal-table">
          <thead>
            <tr id="modal-header-row">
              <th>Row #</th>
              <th>Category</th>
              <th>Amount</th>
            </tr>
          </thead>
          <tbody id="modal-rows"></tbody>
        </table>
        <div class="modal-empty" id="modal-empty" style="display:none;">No rows available for this node.</div>
      </div>
      <div class="modal-resizer" aria-hidden="true"></div>
    </div>
  </div>

<script>
    let MIN_VIZ = 5000;
    let FONT_SIZE = 10;
    const titleEl = document.getElementById('title');
    const fileLabelEl = document.getElementById('file-label');
    const statusEl = document.getElementById('status');
    const tooltip = document.getElementById('tooltip');
    const placeholder = document.getElementById('placeholder');
    const fileInput = document.getElementById('file-input');
    const thresholdInput = document.getElementById('min-viz');
    const fontSizeInput = document.getElementById('font-size');
    const dateControls = document.getElementById('date-controls');
    const minDateInput = document.getElementById('min-date');
    const maxDateInput = document.getElementById('max-date');
    const dateRangeWrapper = document.getElementById('date-range-wrapper');
    const dateRangeSelect = document.getElementById('date-range');
    const dateRangeCustomOption = document.getElementById('date-range-custom');
    const dateRangeCy1Option = document.getElementById('date-range-cy-1');
    const dateRangeCy2Option = document.getElementById('date-range-cy-2');
    const dateRangeCy3Option = document.getElementById('date-range-cy-3');
    const exportFormat = document.getElementById('export-format');
    const exportBtn = document.getElementById('export-btn');
    const resetSuppressedBtn = document.getElementById('reset-suppressed');
    const modalBackdrop = document.getElementById('details-backdrop');
    const modalEl = document.querySelector('.modal');
    const modalHeaderEl = modalEl ? modalEl.querySelector('.modal-header') : null;
    const modalResizer = modalEl ? modalEl.querySelector('.modal-resizer') : null;
    const modalTitle = document.getElementById('modal-title');
    const modalSubtitle = document.getElementById('modal-subtitle');
    const modalTableWrap = document.querySelector('.modal-table-wrap');
    const modalRowsBody = document.getElementById('modal-rows');
    const modalHeaderRow = document.getElementById('modal-header-row');
    const modalEmpty = document.getElementById('modal-empty');
    const modalCloseBtn = document.getElementById('modal-close');
    const downloadRowsBtn = document.getElementById('download-rows');
    const ROW_NUMBER_KEY = '__row_number__';
    let currentFileName = 'quicken_export.xlsx';
    let modalRowsData = [];
    let lastHeaders = [];
    let modalSort = { key: 'Category', dir: 'asc' };
    let isModalDragging = false;
    let modalDragOffsetX = 0;
    let modalDragOffsetY = 0;
    let isModalResizing = false;
    let modalResizeStart = null;
    let isInScrollbarGutter = false;
    let lastScrollbarNudge = 0;
    let lastModalPointerDown = 0;
    let isModalPointerDown = false;
    let suppressedRowNumbers = new Set();
    let baseRows = [];
    let activeDateKey = null;
    let dateBounds = null;
    let dateFilter = { min: null, max: null };
    let userSelectedFile = false;
    const STORAGE_KEY = 'sankey_user_rows_v1';
    const formatNumber = d3.format(',.0f');
    thresholdInput.value = MIN_VIZ;
    fontSizeInput.value = FONT_SIZE;
    updateCalendarYearOptions();
    setCurrentFileName(currentFileName);
    updateThresholdLabel();

    if (modalCloseBtn) {
      modalCloseBtn.addEventListener('click', hideModal);
    }
    if (modalBackdrop) {
      modalBackdrop.addEventListener('click', (e) => {
        if (e.target !== modalBackdrop) return;
        if (isModalPointerDown || Date.now() - lastModalPointerDown < 2000) {
          lastModalPointerDown = 0;
          return;
        }
        hideModal();
      });
    }
    if (modalEl) {
      modalEl.addEventListener('pointerdown', () => {
        isModalPointerDown = true;
        lastModalPointerDown = Date.now();
      });
    }
    document.addEventListener('pointerup', () => {
      isModalPointerDown = false;
    });
    if (modalResizer && modalEl) {
      modalResizer.addEventListener('pointerdown', (event) => {
        if (event.button !== 0) return;
        startModalResize(event);
      });
    }
    if (modalHeaderEl && modalEl) {
      modalHeaderEl.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return;
        if (event.target.closest('.modal-close')) return;
        startModalDrag(event);
      });
    }
    if (downloadRowsBtn) {
      downloadRowsBtn.addEventListener('click', () => {
        if (!modalRowsData.length) return;
        downloadRowsCsv(modalRowsData, 'sankey_data.csv', lastHeaders);
      });
    }
    if (modalHeaderRow) {
      modalHeaderRow.addEventListener('click', (event) => {
        const th = event.target.closest('th');
        if (!th || !modalHeaderRow.contains(th)) return;
        const key = th.dataset.key;
        if (!key) return;
        modalSort = {
          key,
          dir: modalSort.key === key && modalSort.dir === 'asc' ? 'desc' : 'asc'
        };
        renderModalRows(modalRowsData, lastHeaders);
      });
    }
    if (resetSuppressedBtn) {
      resetSuppressedBtn.addEventListener('click', () => {
        if (!baseRows.length) {
          statusEl.textContent = 'Load a file before resetting suppressed rows.';
          return;
        }
        if (!suppressedRowNumbers.size) {
          statusEl.textContent = 'No suppressed rows to reset.';
          return;
        }
        suppressedRowNumbers.clear();
        window.__suppressedRowNumbers = suppressedRowNumbers;
        renderFromRows();
      });
    }
    if (minDateInput) {
      minDateInput.addEventListener('change', () => {
        if (dateRangeCustomOption) dateRangeCustomOption.hidden = false;
        if (dateRangeSelect) dateRangeSelect.value = 'custom';
        updateDateFilter('min');
      });
    }
    if (maxDateInput) {
      maxDateInput.addEventListener('change', () => {
        if (dateRangeCustomOption) dateRangeCustomOption.hidden = false;
        if (dateRangeSelect) dateRangeSelect.value = 'custom';
        updateDateFilter('max');
      });
    }
    if (dateRangeSelect) {
      dateRangeSelect.addEventListener('change', () => {
        applyDateRangePreset(dateRangeSelect.value);
      });
    }
    if (modalTableWrap) {
      modalTableWrap.addEventListener('mousemove', handleScrollbarGutterHover);
      modalTableWrap.addEventListener('mouseleave', () => {
        isInScrollbarGutter = false;
      });
    }

    function setCurrentFileName(name) {
      currentFileName = name || 'quicken_export.xlsx';
      if (titleEl) {
        titleEl.textContent = `Sankey Overview - ${currentFileName}`;
      }
      if (fileLabelEl) {
        fileLabelEl.textContent = currentFileName;
      }
      document.title = `Sankey Overview - ${currentFileName}`;
    }

    function setModalHeaders(headers) {
      if (!modalHeaderRow) return;
      const cols = [
        { label: 'Export Row #', key: ROW_NUMBER_KEY },
        ...(headers || []).map(h => ({ label: h, key: String(h || '') }))
      ];
      modalHeaderRow.innerHTML = cols.map((col) => {
        const isActive = modalSort && modalSort.key === col.key;
        const indicator = isActive ? (modalSort.dir === 'asc' ? ' ^' : ' v') : '';
        return `<th class="sortable${isActive ? ' is-sorted' : ''}" data-key="${escapeHtml(String(col.key))}">${escapeHtml(String(col.label || ''))}${indicator}</th>`;
      }).join('');
    }

    function updateThresholdLabel() {
      if (document.getElementById('threshold-label')) {
        document.getElementById('threshold-label').textContent = MIN_VIZ.toLocaleString('en-US');
      }
    }

    function handleScrollbarGutterHover(event) {
      if (!modalTableWrap) return;
      const rect = modalTableWrap.getBoundingClientRect();
      const gutterSize = 16;
      const inGutter = event.clientX >= rect.right - gutterSize || event.clientY >= rect.bottom - gutterSize;
      if (inGutter && !isInScrollbarGutter) {
        isInScrollbarGutter = true;
        nudgeScrollbars();
      } else if (!inGutter && isInScrollbarGutter) {
        isInScrollbarGutter = false;
      }
    }

    function nudgeScrollbars() {
      if (!modalTableWrap) return;
      const now = Date.now();
      if (now - lastScrollbarNudge < 400) return;
      lastScrollbarNudge = now;
      const left = modalTableWrap.scrollLeft;
      const top = modalTableWrap.scrollTop;
      modalTableWrap.scrollLeft = left + 1;
      modalTableWrap.scrollTop = top + 1;
      modalTableWrap.scrollLeft = left;
      modalTableWrap.scrollTop = top;
    }

    function startModalDrag(event) {
      if (!modalEl) return;
      const rect = modalEl.getBoundingClientRect();
      modalEl.style.left = `${rect.left}px`;
      modalEl.style.top = `${rect.top}px`;
      modalEl.style.transform = 'none';
      isModalDragging = true;
      modalDragOffsetX = event.clientX - rect.left;
      modalDragOffsetY = event.clientY - rect.top;
      document.addEventListener('mousemove', onModalDrag);
      document.addEventListener('mouseup', stopModalDrag);
      event.preventDefault();
    }

    function onModalDrag(event) {
      if (!isModalDragging || !modalEl) return;
      const maxLeft = Math.max(0, window.innerWidth - modalEl.offsetWidth);
      const maxTop = Math.max(0, window.innerHeight - modalEl.offsetHeight);
      const nextLeft = Math.min(Math.max(0, event.clientX - modalDragOffsetX), maxLeft);
      const nextTop = Math.min(Math.max(0, event.clientY - modalDragOffsetY), maxTop);
      modalEl.style.left = `${nextLeft}px`;
      modalEl.style.top = `${nextTop}px`;
    }

    function stopModalDrag() {
      if (!isModalDragging) return;
      isModalDragging = false;
      document.removeEventListener('mousemove', onModalDrag);
      document.removeEventListener('mouseup', stopModalDrag);
    }

    function startModalResize(event) {
      if (!modalEl) return;
      const rect = modalEl.getBoundingClientRect();
      modalResizeStart = {
        x: event.clientX,
        y: event.clientY,
        width: rect.width,
        height: rect.height,
        left: rect.left,
        top: rect.top
      };
      modalEl.style.left = `${rect.left}px`;
      modalEl.style.top = `${rect.top}px`;
      modalEl.style.transform = 'none';
      isModalResizing = true;
      if (event.pointerId != null && modalResizer) {
        modalResizer.setPointerCapture(event.pointerId);
      }
      document.addEventListener('pointermove', onModalResize);
      document.addEventListener('pointerup', stopModalResize);
      event.preventDefault();
    }

    function onModalResize(event) {
      if (!isModalResizing || !modalEl || !modalResizeStart) return;
      const minWidth = 640;
      const minHeight = 360;
      const maxWidth = window.innerWidth - modalResizeStart.left;
      const maxHeight = window.innerHeight - modalResizeStart.top;
      const nextWidth = Math.min(
        Math.max(minWidth, modalResizeStart.width + (event.clientX - modalResizeStart.x)),
        Math.max(minWidth, maxWidth)
      );
      const nextHeight = Math.min(
        Math.max(minHeight, modalResizeStart.height + (event.clientY - modalResizeStart.y)),
        Math.max(minHeight, maxHeight)
      );
      modalEl.style.width = `${nextWidth}px`;
      modalEl.style.height = `${nextHeight}px`;
    }

    function stopModalResize(event) {
      if (!isModalResizing) return;
      isModalResizing = false;
      modalResizeStart = null;
      document.removeEventListener('pointermove', onModalResize);
      document.removeEventListener('pointerup', stopModalResize);
      if (event && event.pointerId != null && modalResizer) {
        modalResizer.releasePointerCapture(event.pointerId);
      }
    }

    function normalizeModalPosition() {
      if (!modalEl) return;
      const rect = modalEl.getBoundingClientRect();
      const maxLeft = Math.max(0, window.innerWidth - rect.width);
      const maxTop = Math.max(0, window.innerHeight - rect.height);
      const nextLeft = Math.min(Math.max(0, rect.left), maxLeft);
      const nextTop = Math.min(Math.max(0, rect.top), maxTop);
      modalEl.style.left = `${nextLeft}px`;
      modalEl.style.top = `${nextTop}px`;
      modalEl.style.transform = 'none';
    }

    function updateCalendarYearOptions() {
      const now = new Date();
      const currentYear = now.getFullYear();
      const defs = [
        { offset: 1, el: dateRangeCy1Option },
        { offset: 2, el: dateRangeCy2Option },
        { offset: 3, el: dateRangeCy3Option }
      ];
      defs.forEach(({ offset, el }) => {
        if (!el) return;
        const year = currentYear - offset;
        el.textContent = `CY ${year}`;
        el.dataset.year = String(year);
      });
    }

    function setDateControls(dateKey, range) {
      if (!dateControls || !minDateInput || !maxDateInput) return;
      if (!dateKey || !range || !Number.isFinite(range.min) || !Number.isFinite(range.max)) {
        activeDateKey = null;
        dateBounds = null;
        dateFilter = { min: null, max: null };
        dateControls.style.display = 'none';
        minDateInput.value = '';
        maxDateInput.value = '';
        if (dateRangeWrapper) dateRangeWrapper.style.display = 'none';
        return;
      }
      const minLabel = formatDateInput(range.min);
      const maxLabel = formatDateInput(range.max);
      const minValue = parseDateInputValue(minLabel, false);
      const maxValue = parseDateInputValue(maxLabel, true);
      if (!Number.isFinite(minValue) || !Number.isFinite(maxValue)) {
        activeDateKey = null;
        dateBounds = null;
        dateFilter = { min: null, max: null };
        dateControls.style.display = 'none';
        minDateInput.value = '';
        maxDateInput.value = '';
        if (dateRangeWrapper) dateRangeWrapper.style.display = 'none';
        return;
      }
      activeDateKey = dateKey;
      dateBounds = { min: minValue, max: maxValue };
      dateFilter = { min: minValue, max: maxValue };
      minDateInput.min = minLabel;
      minDateInput.max = maxLabel;
      maxDateInput.min = minLabel;
      maxDateInput.max = maxLabel;
      minDateInput.value = minLabel;
      maxDateInput.value = maxLabel;
      dateControls.style.display = 'flex';
      if (dateRangeWrapper) dateRangeWrapper.style.display = 'flex';
      if (dateRangeSelect) dateRangeSelect.value = 'all';
      if (dateRangeCustomOption) dateRangeCustomOption.hidden = true;
    }

    function updateDateFilter(changed) {
      if (!activeDateKey || !dateBounds || !minDateInput || !maxDateInput) return;
      let minValue = parseDateInputValue(minDateInput.value, false);
      let maxValue = parseDateInputValue(maxDateInput.value, true);
      if (!Number.isFinite(minValue)) minValue = dateBounds.min;
      if (!Number.isFinite(maxValue)) maxValue = dateBounds.max;
      if (minValue > maxValue) {
        if (changed === 'min') {
          maxValue = minValue;
          maxDateInput.value = formatDateInput(maxValue);
        } else {
          minValue = maxValue;
          minDateInput.value = formatDateInput(minValue);
        }
      }
      dateFilter = { min: minValue, max: maxValue };
      if (baseRows.length) {
        renderFromRows();
      }
    }

    function applyDateRangePreset(preset) {
      if (!activeDateKey || !dateBounds || !minDateInput || !maxDateInput) return;
      if (preset === 'custom') {
        updateDateFilter('max');
        return;
      }
      let minLabel = '';
      let maxLabel = '';
      if (preset === 'ytd') {
        const now = new Date();
        const year = now.getFullYear();
        minLabel = formatDateInput(new Date(year, 0, 1).getTime());
        maxLabel = formatDateInput(now.getTime());
      } else if (preset.startsWith('cy-')) {
        const option = dateRangeSelect
          ? dateRangeSelect.querySelector(`option[value="${preset}"]`)
          : null;
        const datasetYear = option?.dataset?.year ? Number(option.dataset.year) : null;
        let year = Number.isFinite(datasetYear) ? datasetYear : null;
        if (!Number.isFinite(year)) {
          const offset = Number(preset.split('-')[1]);
          if (Number.isFinite(offset)) year = new Date().getFullYear() - offset;
        }
        if (Number.isFinite(year)) {
          minLabel = formatDateInput(new Date(year, 0, 1).getTime());
          maxLabel = formatDateInput(new Date(year, 11, 31).getTime());
        }
      } else if (preset === 'rolling-12mo') {
        const maxDate = new Date(dateBounds.max);
        const minDate = new Date(dateBounds.max);
        minDate.setMonth(minDate.getMonth() - 12);
        minLabel = formatDateInput(minDate.getTime());
        maxLabel = formatDateInput(maxDate.getTime());
      } else if (preset === 'rolling-24mo') {
        const maxDate = new Date(dateBounds.max);
        const minDate = new Date(dateBounds.max);
        minDate.setMonth(minDate.getMonth() - 24);
        minLabel = formatDateInput(minDate.getTime());
        maxLabel = formatDateInput(maxDate.getTime());
      } else if (preset === 'rolling-36mo') {
        const maxDate = new Date();
        const minDate = new Date(maxDate);
        minDate.setFullYear(minDate.getFullYear() - 3);
        minLabel = formatDateInput(minDate.getTime());
        maxLabel = formatDateInput(maxDate.getTime());
      } else {
        minLabel = formatDateInput(dateBounds.min);
        maxLabel = formatDateInput(dateBounds.max);
      }
      minDateInput.value = minLabel;
      maxDateInput.value = maxLabel;
      updateDateFilter('max');
    }

    function parseDateInputValue(value, isEndOfDay) {
      if (!value) return null;
      const date = new Date(`${value}T00:00:00`);
      if (Number.isNaN(date.getTime())) return null;
      if (isEndOfDay) {
        date.setHours(23, 59, 59, 999);
      }
      return date.getTime();
    }

    function formatDateInput(ts) {
      if (!Number.isFinite(ts)) return '';
      const date = new Date(ts);
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      userSelectedFile = true;
      setCurrentFileName(file.name);
      statusEl.textContent = `Reading ${file.name}...`;
      readFileAsArrayBuffer(file)
        .then(buffer => renderFromArrayBuffer(buffer, file.name))
        .catch(showError);
    });

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (evt) => resolve(evt.target.result);
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    function setBaseRows(rows) {
      baseRows = Array.isArray(rows) ? rows.slice() : [];
      if (activeDateKey) {
        baseRows.forEach((row) => {
          if (!Number.isFinite(row.dateTimestamp)) {
            const rawValue = getRowDateValue(row, activeDateKey);
            row.dateTimestamp = parseDateValue(rawValue);
          }
        });
      }
      suppressedRowNumbers = new Set();
      window.__baseRows = baseRows;
      window.__suppressedRowNumbers = suppressedRowNumbers;
      window.__lastRows = baseRows;
    }

    function saveUserState(rows, headers, fileName, dateKey, dateRange) {
      if (!window.sessionStorage) return;
      try {
        const payload = {
          rows: Array.isArray(rows) ? rows : [],
          headers: Array.isArray(headers) ? headers : [],
          fileName: fileName || 'quicken_export.xlsx',
          dateKey: dateKey || null,
          dateRange: dateRange || null
        };
        sessionStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Unable to persist user-selected data file.', err);
      }
    }

    function tryRestoreUserState() {
      if (!window.sessionStorage) return false;
      const raw = sessionStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      try {
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.rows) || !data.rows.length) return false;
        const cachedRows = data.rows.filter((row) => {
          const rawAmount = Number(row?.raw?.Amount);
          if (Number.isFinite(rawAmount)) return rawAmount < 0;
          return true;
        });
        if (!cachedRows.length) return false;
        userSelectedFile = true;
        setCurrentFileName(data.fileName || 'quicken_export.xlsx');
        lastHeaders = Array.isArray(data.headers) ? data.headers : [];
        const dateKey = data.dateKey || findDateKey(lastHeaders, cachedRows);
        const dateRange = data.dateRange || (dateKey ? getDateRange(cachedRows, dateKey) : null);
        setDateControls(dateKey, dateRange);
        setBaseRows(cachedRows);
        renderFromRows();
        statusEl.textContent = `Loaded cached data from ${data.fileName || 'selected file'}.`;
        return true;
      } catch (err) {
        console.warn('Unable to restore cached data.', err);
        return false;
      }
    }

    function getActiveRows() {
      let rows = baseRows.slice();
      if (suppressedRowNumbers && suppressedRowNumbers.size) {
        rows = rows.filter(r => !suppressedRowNumbers.has(r.rowNumber));
      }
      if (activeDateKey && dateFilter && Number.isFinite(dateFilter.min) && Number.isFinite(dateFilter.max)) {
        const min = dateFilter.min;
        const max = dateFilter.max;
        rows = rows.filter((row) => {
          const ts = Number.isFinite(row.dateTimestamp)
            ? row.dateTimestamp
            : parseDateValue(getRowDateValue(row, activeDateKey));
          if (!Number.isFinite(ts)) return false;
          return ts >= min && ts <= max;
        });
      }
      return rows;
    }

    async function loadDefaultWorkbook() {
      if (userSelectedFile) return;
      try {
        const resp = await fetch('quicken_export.xlsx');
        if (!resp.ok) throw new Error('Default workbook not found.');
        const buffer = await resp.arrayBuffer();
        if (userSelectedFile) return;
        await renderFromArrayBuffer(buffer, 'quicken_export.xlsx', { isDefault: true });
      } catch (err) {
        statusEl.textContent = 'Pick a file to render.';
        setPlaceholder('No chart yet. If you opened this file directly, the browser may block loading quicken_export.xlsx. Start a local server (e.g. `python -m http.server 8000`) or use “Load another file”.');
      }
    }

    thresholdInput.addEventListener('change', () => {
      const val = Number(thresholdInput.value);
      MIN_VIZ = Number.isFinite(val) && val >= 0 ? val : 5000;
      thresholdInput.value = MIN_VIZ;
      updateThresholdLabel();
      if (baseRows.length) {
        renderFromRows();
      }
    });

    fontSizeInput.addEventListener('change', () => {
      const val = Number(fontSizeInput.value);
      FONT_SIZE = Number.isFinite(val) && val >= 6 ? Math.min(val, 32) : 10;
      fontSizeInput.value = FONT_SIZE;
      if (baseRows.length) {
        renderFromRows();
      }
    });

    exportBtn.addEventListener('click', async () => {
      const svgEl = document.querySelector('#chart svg');
      if (!svgEl) {
        statusEl.textContent = 'Render the chart before exporting.';
        return;
      }
      const fmt = exportFormat.value === 'svg' ? 'svg' : 'png';
      statusEl.textContent = `Saving ${fmt.toUpperCase()}...`;
      try {
        await exportChart(svgEl, fmt);
        statusEl.textContent = `Saved ${fmt.toUpperCase()} chart.`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = err.message || 'Failed to export chart.';
      }
    });

    async function renderFromArrayBuffer(buffer, fileName = 'quicken_export.xlsx', opts = {}) {
      const isDefault = opts && opts.isDefault;
      if (isDefault && userSelectedFile) return;
      try {
        const workbook = XLSX.read(buffer, { type: 'array' });
        const { expenses, headers, dateKey, dateRange } = extractRows(workbook);
        setDateControls(dateKey, dateRange);
        setBaseRows(expenses);
        lastHeaders = headers;
        renderFromRows();
        setCurrentFileName(fileName);
        if (!isDefault) {
          userSelectedFile = true;
          saveUserState(expenses, headers, fileName, dateKey, dateRange);
        }
      } catch (err) {
        showError(err);
      }
    }

    function renderFromRows(rows = getActiveRows()) {
      const activeRows = Array.isArray(rows) ? rows : [];
      const suppressedCount = suppressedRowNumbers?.size ? suppressedRowNumbers.size : 0;
      const dateFilterActive = activeDateKey && dateFilter && Number.isFinite(dateFilter.min) && Number.isFinite(dateFilter.max);
      const unsuppressedRows = suppressedCount
        ? baseRows.filter(r => !suppressedRowNumbers.has(r.rowNumber))
        : baseRows;
      const dateFilteredOut = dateFilterActive
        ? Math.max(0, unsuppressedRows.length - activeRows.length)
        : 0;
      window.__lastRows = activeRows;
      if (!activeRows.length) {
        window.__lastSankeyData = null;
        clearChart();
        setPlaceholder('No data to render. Suppress fewer nodes or load another file.');
        if (dateFilterActive && unsuppressedRows.length) {
          statusEl.textContent = 'No rows in the selected date range.';
        } else {
          statusEl.textContent = suppressedCount
            ? `All ${suppressedCount} rows suppressed. Nothing to render.`
            : 'No expense rows to render.';
        }
        return;
      }
      const tree = buildHierarchy(activeRows);
      collapseSmallNodes(tree);
      const sankeyData = treeToSankey(tree);
      window.__lastSankeyData = sankeyData;
      drawChart(sankeyData);
      statusEl.textContent = `Rendered ${activeRows.length} expense rows (min threshold $${MIN_VIZ})${suppressedCount ? `, suppressed ${suppressedCount}` : ''}${dateFilteredOut ? `, filtered ${dateFilteredOut} by date` : ''}.`;
    }

    function clearChart() {
      const container = document.getElementById('chart');
      if (!container) return;
      container.querySelectorAll('svg').forEach(el => el.remove());
      window.__lastSvg = null;
    }

    function normalizeCellValue(key, val) {
      if (val instanceof Date) {
        return formatDateFromDate(val);
      }
      if (typeof val === 'string' && /date/i.test(key)) {
        const maybe = new Date(val);
        if (!Number.isNaN(maybe.getTime())) {
          return formatDateFromDate(maybe);
        }
      }
      if (typeof val === 'number' && Number.isFinite(val) && /date/i.test(key)) {
        const parsed = XLSX?.SSF?.parse_date_code ? XLSX.SSF.parse_date_code(val) : null;
        if (parsed && parsed.y && parsed.m && parsed.d) {
          return formatDateFromParts(parsed);
        }
      }
      return val;
    }

    function formatDateFromDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const hasTime = d.getHours() || d.getMinutes() || d.getSeconds();
      if (!hasTime) return `${y}-${m}-${day}`;
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
    }

    function formatDateFromParts(p) {
      const y = p.y;
      const m = String(p.m || 1).padStart(2, '0');
      const d = String(p.d || 1).padStart(2, '0');
      const hasTime = p.H || p.M || p.S;
      if (!hasTime) return `${y}-${m}-${d}`;
      const hh = String(p.H || 0).padStart(2, '0');
      const mm = String(p.M || 0).padStart(2, '0');
      const ss = String(Math.floor(p.S || 0)).padStart(2, '0');
      return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
    }

    function normalizeRow(row) {
      const out = {};
      Object.entries(row).forEach(([k, v]) => {
        out[k] = normalizeCellValue(k, v);
      });
      return out;
    }

    function findDateKey(headers, rows) {
      const headerList = Array.isArray(headers) ? headers : [];
      const exact = headerList.find(h => String(h || '').trim().toLowerCase() === 'date');
      if (exact) return exact;
      const fuzzy = headerList.find(h => /date/i.test(String(h || '')));
      if (fuzzy) return fuzzy;
      const sample = rows && rows.length ? Object.keys(rows[0]) : [];
      const sampleExact = sample.find(k => String(k || '').trim().toLowerCase() === 'date');
      if (sampleExact) return sampleExact;
      const sampleFuzzy = sample.find(k => /date/i.test(String(k || '')));
      return sampleFuzzy || null;
    }

    function getRowDateValue(row, dateKey) {
      if (!row || !dateKey) return null;
      if (row[dateKey] != null && row[dateKey] !== '') return row[dateKey];
      if (row.raw && row.raw[dateKey] != null && row.raw[dateKey] !== '') {
        return row.raw[dateKey];
      }
      return null;
    }

    function parseDateValue(value) {
      if (value == null || value === '') return null;
      if (value instanceof Date) {
        const time = value.getTime();
        return Number.isNaN(time) ? null : time;
      }
      if (typeof value === 'number' && Number.isFinite(value)) {
        const parsed = XLSX?.SSF?.parse_date_code ? XLSX.SSF.parse_date_code(value) : null;
        if (parsed && parsed.y && parsed.m && parsed.d) {
          const date = new Date(
            parsed.y,
            (parsed.m || 1) - 1,
            parsed.d || 1,
            parsed.H || 0,
            parsed.M || 0,
            Math.floor(parsed.S || 0)
          );
          const time = date.getTime();
          return Number.isNaN(time) ? null : time;
        }
      }
      const str = String(value).trim();
      if (!str) return null;
      let iso = str;
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
        iso = `${str}T00:00:00`;
      } else if (/^\d{4}-\d{2}-\d{2} /.test(str)) {
        iso = str.replace(' ', 'T');
      }
      const time = new Date(iso).getTime();
      if (!Number.isNaN(time)) return time;
      const fallback = new Date(str).getTime();
      return Number.isNaN(fallback) ? null : fallback;
    }

    function getDateRange(rows, dateKey) {
      if (!dateKey || !Array.isArray(rows) || !rows.length) return null;
      let min = null;
      let max = null;
      rows.forEach((row) => {
        const rawValue = getRowDateValue(row, dateKey);
        const ts = parseDateValue(rawValue);
        if (!Number.isFinite(ts)) return;
        if (min == null || ts < min) min = ts;
        if (max == null || ts > max) max = ts;
      });
      if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
      return { min, max };
    }

    function isBlankValue(value) {
      return value == null || (typeof value === 'string' && value.trim() === '');
    }

    function trimQuickenRows(rows) {
      const trimmedTop = rows.length > 4 ? rows.slice(4) : [];
      let totalInflowsRow = -1;
      for (let i = 0; i < trimmedTop.length; i += 1) {
        if (trimmedTop[i]?.[1] === 'TOTAL INFLOWS') {
          totalInflowsRow = i;
          break;
        }
      }
      if (totalInflowsRow === -1) return trimmedTop;
      const startDelete = Math.max(0, totalInflowsRow - 2);
      return trimmedTop.slice(0, startDelete);
    }

    function findHeaderColumnIndex(rows, headerName) {
      if (!rows.length) return null;
      const headers = Array.isArray(rows[0]) ? rows[0] : [];
      const target = headerName.trim().toLowerCase();
      for (let i = 0; i < headers.length; i += 1) {
        const cell = headers[i];
        if (typeof cell === 'string' && cell.trim().toLowerCase() === target) {
          return i;
        }
      }
      return null;
    }

    function downfillColumn(rows, colIndex, isRealValue = (value) => !isBlankValue(value)) {
      if (colIndex == null || colIndex < 0) return;
      let lastValue = null;
      for (let i = 1; i < rows.length; i += 1) {
        if (!Array.isArray(rows[i])) rows[i] = [];
        const row = rows[i];
        const value = row[colIndex];
        if (isRealValue(value)) {
          lastValue = value;
          continue;
        }
        if (isBlankValue(value) && lastValue != null) {
          row[colIndex] = lastValue;
        }
      }
    }

    function isRealDateValue(value) {
      return parseDateValue(value) != null;
    }

    function extractRows(workbook) {
      const firstSheet = workbook.SheetNames[0];
      const sheet = workbook.Sheets[firstSheet];
      const headerRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '', raw: true, cellDates: true });
      const trimmedRows = trimQuickenRows(headerRows);
      const headerRow = Array.isArray(trimmedRows[0]) ? trimmedRows[0] : [];
      const headers = headerRow.filter(h => String(h || '').trim() !== '');
      const dateColIndex = findHeaderColumnIndex(trimmedRows, 'Date');
      const descColIndex = findHeaderColumnIndex(trimmedRows, 'Description');
      downfillColumn(trimmedRows, dateColIndex, isRealDateValue);
      downfillColumn(trimmedRows, descColIndex);
      const rowsRaw = trimmedRows.slice(1).map((row) => {
        const out = {};
        if (!Array.isArray(row)) return out;
        headerRow.forEach((header, idx) => {
          const key = String(header || '').trim();
          if (!key) return;
          out[key] = row[idx];
        });
        return out;
      });
      const normalizedRows = rowsRaw.map(normalizeRow);
      const dateKey = findDateKey(headers, normalizedRows);
      const dateRange = dateKey ? getDateRange(normalizedRows, dateKey) : null;
      const expenses = normalizedRows
        .map((row, idx) => {
          const category = String(row.Category || '').trim();
          const amount = Number(row.Amount);
          const dateTimestamp = dateKey ? parseDateValue(getRowDateValue(row, dateKey)) : null;
          return {
            category,
            amount,
            rowNumber: idx + 1,
            dateTimestamp,
            raw: row
          };
        })
        .filter(r => r.category && Number.isFinite(r.amount) && r.amount < 0)
        .map(r => ({
          category: r.category,
          amount: Math.abs(r.amount),
          rowNumber: r.rowNumber,
          dateTimestamp: r.dateTimestamp,
          raw: r.raw
        }));
      if (!expenses.length) throw new Error('No expenses found. Ensure the sheet has negative Amount values.');
      return { expenses, headers, dateKey, dateRange };
    }

    function makeNode(name, path = name) {
      return { name, path, value: 0, children: new Map(), aggregated: false, aggregatedDetails: [], rows: [] };
    }

    function buildHierarchy(rows) {
      const root = makeNode('Expenses', 'Expenses');
      for (const row of rows) {
        const parts = row.category.split(':').map(p => p.trim()).filter(Boolean);
        if (!parts.length) continue;
        let current = root;
        let currentPath = '';
        for (const part of parts) {
          const childPath = currentPath ? `${currentPath}:${part}` : part;
          if (!current.children.has(part)) current.children.set(part, makeNode(part, childPath));
          current = current.children.get(part);
          currentPath = childPath;
        }
        current.value += row.amount;
        current.rows.push(row);
      }
      propagateTotals(root);
      root.value = Array.from(root.children.values()).reduce((sum, child) => sum + child.value, 0);
      return root;
    }

    function propagateTotals(node) {
      for (const child of node.children.values()) {
        propagateTotals(child);
        node.value += child.value;
        if (child.rows && child.rows.length) {
          node.rows.push(...child.rows);
        }
      }
    }

    function collapseSmallNodes(node) {
      if (!node.children.size) return;
      const children = Array.from(node.children.values());
      const keepers = [];
      const small = [];
      for (const child of children) {
        if (child.value < MIN_VIZ) {
          small.push(child);
        } else {
          collapseSmallNodes(child);
          keepers.push(child);
        }
      }
      if (small.length >= 2) {
        const otherValue = small.reduce((sum, c) => sum + c.value, 0);
        const parentPath = node.path || node.name;
        const otherNode = makeNode('Other', `${parentPath}:Other`);
        otherNode.value = otherValue;
        otherNode.aggregated = true;
        otherNode.aggregatedDetails = small.map(c => ({ name: c.name, value: c.value }));
        otherNode.rows = small.flatMap(c => c.rows || []);
        keepers.push(otherNode);
      } else if (small.length === 1) {
        // Do not aggregate or recurse a lone small node; keep it as-is
        keepers.push(small[0]);
      }
      const ordered = keepers.sort((a, b) => b.value - a.value);
      node.children = new Map(ordered.map((c, idx) => [`${c.name}_${idx}`, c]));
    }

    function treeToSankey(root) {
      const nodes = [];
      const links = [];

      function addNode(node, depth) {
        const idx = nodes.length;
        nodes.push({
          name: node.name,
          path: node.path,
          value: node.value,
          aggregated: node.aggregated,
          aggregatedDetails: node.aggregatedDetails ? [...node.aggregatedDetails] : [],
          rows: node.rows ? [...node.rows] : [],
          depth
        });
        return idx;
      }

      function walk(node, depth, parentIndex = null) {
        const index = addNode(node, depth);
        if (parentIndex !== null) {
          links.push({
            source: parentIndex,
            target: index,
            value: node.value,
            aggregatedDetails: node.aggregated ? node.aggregatedDetails : null
          });
        }
        const childEntries = Array.from(node.children.values()).sort((a, b) => a.name.localeCompare(b.name));
        for (const child of childEntries) {
          walk(child, depth + 1, index);
        }
      }
      walk(root, 0, null);
      return { nodes, links };
    }

    function drawChart({ nodes, links }) {
      const container = document.getElementById('chart');
      clearChart();

      const width = Math.max(1600, Math.min(1200, container.clientWidth - 12));
      const height = Math.max(800, Math.min(container.clientHeight, window.innerHeight - 140));
      const topPadding = 30;
      const bottomPadding = 30;
      const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const sankey = d3.sankey()
        .nodeId((d, i) => i)
        .nodeWidth(12)
        .nodePadding(70)
        .extent([[0, topPadding], [width, height - bottomPadding]])
        .nodeAlign(d3.sankeyLeft)
        // Let d3 find the best order to reduce crossings
        .nodeSort(null)
        .linkSort(null)
        .iterations(64);

      const graph = sankey({
        nodes: nodes.map(d => Object.assign({}, d)),
        links: links.map(d => Object.assign({}, d))
      });

      enforceValueHeights(graph, height, topPadding, bottomPadding);
      const newHeight = Math.max(
        height,
        d3.max(graph.nodes, d => d.y1 || 0) + 20
      );
      svg
        .attr('height', newHeight)
        .attr('viewBox', `0 0 ${width} ${newHeight}`);

      const color = d3.scaleOrdinal(d3.schemeCategory10);
      const formatValue = d3.format(',.0f');

      const link = svg.append('g')
        .attr('fill', 'none')
        .selectAll('path')
        .data(graph.links)
        .join('path')
        .attr('class', 'link')
        .attr('d', stackedLink)
        .attr('stroke', d => color(d.target.index))
        .attr('stroke-width', d => Math.max(1, d.width))
        .on('mousemove', (event, d) => showTooltip(event, d, formatValue))
        .on('mouseleave', hideTooltip)
        .on('click', (event, d) => promptSuppression(event, d.target));

      const node = svg.append('g')
        .selectAll('g')
        .data(graph.nodes)
        .join('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x0},${d.y0})`)
        .on('click', (event, d) => {
          showNodeDetails(d);
        });

      node.append('rect')
        .attr('height', d => d.y1 - d.y0)
        .attr('width', d => d.x1 - d.x0)
        .attr('fill', d => color(d.index));

      node.append('text')
        .attr('x', d => d.name === 'Expenses' ? (d.x1 - d.x0) + 6 : -6)
        .attr('y', d => (d.y1 - d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', d => d.name === 'Expenses' ? 'start' : 'end')
        .style('font-size', `${FONT_SIZE}px`)
        .text(d => `${d.name}: $${formatValue(d.value)} USD`);

      window.__lastSvg = svg.node();
      setPlaceholder('');
    }

    function showNodeDetails(node) {
      if (!node || !modalBackdrop) return;
      const rows = Array.isArray(node.rows) ? [...node.rows] : [];
      rows.sort((a, b) => {
        const aNum = Number.isFinite(a.rowNumber) ? a.rowNumber : 0;
        const bNum = Number.isFinite(b.rowNumber) ? b.rowNumber : 0;
        return aNum - bNum;
      });
      modalSort = { key: 'Category', dir: 'asc' };
      modalRowsData = rows;
      if (modalTitle) {
        modalTitle.textContent = `${node.name}`;
      }
      if (modalSubtitle) {
        const rowLabel = rows.length === 1 ? 'row' : 'rows';
        modalSubtitle.textContent = `${rows.length} ${rowLabel} - Total $${formatNumber(node.value || 0)} USD`;
      }
      renderModalRows(rows, lastHeaders);
      modalBackdrop.style.display = 'flex';
      requestAnimationFrame(normalizeModalPosition);
    }

    function renderModalRows(rows, headers = []) {
      if (!modalRowsBody || !modalEmpty) return;
      const effectiveHeaders = (headers && headers.length)
        ? headers
        : (rows[0]?.raw ? Object.keys(rows[0].raw) : []);
      setModalHeaders(effectiveHeaders);
      const sortedRows = sortModalRows(rows, effectiveHeaders);
      modalRowsData = sortedRows;
      modalRowsBody.innerHTML = '';
      if (!sortedRows.length) {
        modalEmpty.style.display = 'block';
        return;
      }
      modalEmpty.style.display = 'none';
      const frag = document.createDocumentFragment();
      sortedRows.forEach((row, idx) => {
        const tr = document.createElement('tr');
        const rowNum = Number.isFinite(row.rowNumber) ? row.rowNumber : idx + 1;
        const cells = [rowNum, ...effectiveHeaders.map(h => row.raw ? row.raw[h] : row[h])];
        tr.innerHTML = cells.map((val, cellIdx) => {
          const safe = escapeHtml(val == null ? '' : String(val));
          return `<td${cellIdx === 1 ? ' class=\"category\"' : ''}>${safe}</td>`;
        }).join('');
        frag.appendChild(tr);
      });
      modalRowsBody.appendChild(frag);
    }

    function hideModal() {
      if (modalBackdrop) modalBackdrop.style.display = 'none';
      modalRowsData = [];
    }

    function downloadRowsCsv(rows, filename = 'sankey_data.csv', headers = lastHeaders) {
      if (!rows.length) return;
      const effectiveHeaders = (headers && headers.length)
        ? headers
        : (rows[0]?.raw ? Object.keys(rows[0].raw) : []);
      const lines = [];
      lines.push(['row_number', ...effectiveHeaders].map(csvEscape).join(','));
      rows.forEach((r, idx) => {
        const rowNum = Number.isFinite(r.rowNumber) ? r.rowNumber : idx + 1;
        const values = effectiveHeaders.map(h => csvEscape(r.raw ? r.raw[h] : r[h]));
        lines.push([rowNum, ...values].join(','));
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = filename;
      document.body.appendChild(anchor);
      anchor.click();
      anchor.remove();
      URL.revokeObjectURL(url);
    }

    function suppressNodeRows(node) {
      if (!node || !Array.isArray(node.rows) || !node.rows.length) return;
      if (!baseRows.length) return;
      node.rows.forEach(r => {
        if (r && Number.isFinite(r.rowNumber)) {
          suppressedRowNumbers.add(r.rowNumber);
        }
      });
      window.__suppressedRowNumbers = suppressedRowNumbers;
      renderFromRows();
    }

    function promptSuppression(event, node) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (!node || !Array.isArray(node.rows) || !node.rows.length) return;
      if (node.name === 'Expenses') return;
      const rowCount = node.rows.length;
      const label = node.path || node.name;
      const confirmMsg = `Suppress "${label}" and all descendant rows (${rowCount} row${rowCount === 1 ? '' : 's'})?`;
      const confirmed = window.confirm(confirmMsg);
      if (!confirmed) return;
      suppressNodeRows(node);
    }

    async function exportChart(svgEl, format) {
      if (format === 'svg') {
        const svgString = serializeSvg(svgEl);
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        await saveBlob(blob, 'sankey.svg', 'image/svg+xml');
        return;
      }

      const { width, height } = getSvgSize(svgEl);
      const svgString = serializeSvg(svgEl);
      const svgBlob = new Blob([svgString], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(svgBlob);

      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob(async (blob) => {
            URL.revokeObjectURL(url);
            if (!blob) {
              reject(new Error('Unable to create PNG blob.'));
              return;
            }
            try {
              await saveBlob(blob, 'sankey.png', 'image/png');
              resolve();
            } catch (err) {
              reject(err);
            }
          }, 'image/png');
        };
        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Failed to load SVG for export.'));
        };
        img.src = url;
      });
    }

    function serializeSvg(svgEl) {
      const clone = svgEl.cloneNode(true);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

      // Inline computed styles so exported SVG/PNG matches on-screen colors
      const srcNodes = svgEl.querySelectorAll('*');
      const dstNodes = clone.querySelectorAll('*');
      srcNodes.forEach((node, idx) => {
        const target = dstNodes[idx];
        if (!target) return;
        const styles = getComputedStyle(node);
        target.style.fontSize = styles.fontSize;
        target.style.fontFamily = styles.fontFamily;
        target.style.fill = styles.fill;
        target.style.fillOpacity = styles.fillOpacity;
        target.style.stroke = styles.stroke;
        target.style.strokeWidth = styles.strokeWidth;
        target.style.strokeOpacity = styles.strokeOpacity;
        target.style.opacity = styles.opacity;
      });

      const pageStyle = document.querySelector('style');
      if (pageStyle) {
        const defsStyle = document.createElementNS('http://www.w3.org/2000/svg', 'style');
        defsStyle.textContent = pageStyle.textContent;
        clone.insertBefore(defsStyle, clone.firstChild);
      }

      return new XMLSerializer().serializeToString(clone);
    }

    function getSvgSize(svgEl) {
      const viewBox = svgEl.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/\s+/).map(Number);
        if (parts.length === 4 && parts.every(Number.isFinite)) {
          return { width: parts[2], height: parts[3] };
        }
      }
      const width = svgEl.width?.baseVal?.value || svgEl.getBoundingClientRect().width || 1200;
      const height = svgEl.height?.baseVal?.value || svgEl.getBoundingClientRect().height || 800;
      return { width, height };
    }

    async function saveBlob(blob, defaultName, mimeType) {
      if (window.showSaveFilePicker) {
        const ext = mimeType === 'image/svg+xml'
          ? '.svg'
          : mimeType === 'image/png'
            ? '.png'
            : (defaultName.includes('.') ? defaultName.slice(defaultName.lastIndexOf('.')) : '.csv');
        const handle = await window.showSaveFilePicker({
          suggestedName: defaultName,
          types: [{
            description: mimeType === 'image/svg+xml'
              ? 'SVG Image'
              : mimeType === 'image/png'
                ? 'PNG Image'
                : 'Download',
            accept: { [mimeType]: [ext] }
          }]
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
      } else {
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = defaultName;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        URL.revokeObjectURL(url);
      }
    }

    function enforceValueHeights(graph, height, topPadding = 0, bottomPadding = 0) {
      const padding = 8;
      const byDepth = d3.group(graph.nodes, d => d.depth);
      const available = Math.max(120, height - topPadding - bottomPadding - 8);

      const inflow = new Map();
      const outflow = new Map();
      graph.links.forEach(l => {
        const s = l.source.index;
        const t = l.target.index;
        outflow.set(s, (outflow.get(s) || 0) + l.value);
        inflow.set(t, (inflow.get(t) || 0) + l.value);
      });

      const rootIdx = graph.nodes.findIndex(n => n.name === 'Expenses');

      function desiredValue(node, idx) {
        if (idx === rootIdx) return outflow.get(idx) || node.value || 1e-6;
        const inVal = inflow.get(idx);
        return (inVal != null ? inVal : node.value || 1e-6);
      }

      let scale = 1;
      const scaleCandidates = [];
      byDepth.forEach(list => {
        const total = d3.sum(list, d => desiredValue(d, d.index)) || 1e-6;
        const needed = total + padding * (list.length + 1);
        scaleCandidates.push(available / needed);
      });
      if (scaleCandidates.length) scale = Math.min(...scaleCandidates);
      scale = Math.min(scale, 1);

      byDepth.forEach(list => {
        list.sort((a, b) => a.y0 - b.y0);
        let cursor = topPadding;
        list.forEach(n => {
          const h = Math.max(2, desiredValue(n, n.index) * scale);
          n.y0 = cursor;
          n.y1 = cursor + h;
          cursor = n.y1 + padding;
        });
      });

      graph.links.forEach(l => {
        l.width = Math.max(1, l.value * scale);
      });

      // Sort links globally by source then target to keep consistent stacking and minimize crossings
      graph.links.sort((a, b) => {
        if (a.source.y0 !== b.source.y0) return a.source.y0 - b.source.y0;
        return a.target.y0 - b.target.y0;
      });

      const bySource = d3.group(graph.links, l => l.source.index);
      bySource.forEach((ls, sIdx) => {
        const node = graph.nodes[sIdx];
        ls.sort((a, b) => a.target.y0 - b.target.y0);
        let cursor = node.y0;
        ls.forEach(l => {
          l.y0 = cursor + l.width / 2;
          cursor += l.width;
        });
      });

      const byTarget = d3.group(graph.links, l => l.target.index);
      byTarget.forEach((ls, tIdx) => {
        const node = graph.nodes[tIdx];
        ls.sort((a, b) => a.source.y0 - b.source.y0);
        let cursor = node.y0;
        ls.forEach(l => {
          l.y1 = cursor + l.width / 2;
          cursor += l.width;
        });
      });
    }

    function escapeHtml(str) {
      return str.replace(/[&<>\"']/g, (ch) => {
        switch (ch) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '\"': return '&quot;';
          case '\'': return '&#39;';
          default: return ch;
        }
      });
    }

    function csvEscape(val) {
      if (val == null) return '';
      const str = String(val);
      if (/[\",\n]/.test(str)) {
        return `"${str.replace(/\"/g, '""')}"`;
      }
      return str;
    }

    function sortModalRows(rows, headers) {
      if (!modalSort || !modalSort.key) return rows.slice();
      const key = modalSort.key;
      const dir = modalSort.dir === 'desc' ? -1 : 1;
      const headerSet = new Set(headers || []);
      if (key !== ROW_NUMBER_KEY && !headerSet.has(key)) {
        return rows.slice();
      }
      const withIndex = rows.map((row, idx) => {
        const rawVal = key === ROW_NUMBER_KEY
          ? (Number.isFinite(row.rowNumber) ? row.rowNumber : idx + 1)
          : (row.raw ? row.raw[key] : row[key]);
        return { row, idx, sortVal: coerceSortValue(rawVal) };
      });
      withIndex.sort((a, b) => {
        const cmp = compareSortValues(a.sortVal, b.sortVal);
        if (cmp !== 0) return cmp * dir;
        return a.idx - b.idx;
      });
      return withIndex.map(item => item.row);
    }

    function coerceSortValue(val) {
      if (val == null) return { type: 'empty', value: '' };
      if (typeof val === 'number' && Number.isFinite(val)) {
        return { type: 'number', value: val };
      }
      const str = String(val).trim();
      if (!str) return { type: 'empty', value: '' };
      const cleaned = str.replace(/[$,]/g, '');
      const asNumber = Number(cleaned);
      if (!Number.isNaN(asNumber) && cleaned !== '') {
        return { type: 'number', value: asNumber };
      }
      const asDate = Date.parse(str);
      if (!Number.isNaN(asDate) && /[-\/:]/.test(str)) {
        return { type: 'date', value: asDate };
      }
      return { type: 'string', value: str.toLowerCase() };
    }

    function compareSortValues(a, b) {
      const typeOrder = { number: 0, date: 1, string: 2, empty: 3 };
      if (a.type !== b.type) return typeOrder[a.type] - typeOrder[b.type];
      if (a.type === 'string') return a.value.localeCompare(b.value);
      if (a.value === b.value) return 0;
      return a.value < b.value ? -1 : 1;
    }

    function showTooltip(event, d, formatValue) {
      const source = d.source.name;
      const target = d.target.name;
      const base = `${source} → ${target}: $${formatValue(d.value)} USD`;
      const detail = d.aggregatedDetails && d.aggregatedDetails.length
        ? '\n' + d.aggregatedDetails.map(x => `• ${x.name}: $${formatValue(x.value)}`).join('\n')
        : '';
      tooltip.textContent = base + detail;
      tooltip.style.opacity = 1;
      tooltip.style.transform = 'translate(0, 0)';
      const { clientX, clientY } = event;
      const rect = document.getElementById('chart').getBoundingClientRect();
      const x = clientX - rect.left + document.getElementById('chart').scrollLeft;
      const y = clientY - rect.top + document.getElementById('chart').scrollTop;
      tooltip.style.left = `${x + 4}px`;
      tooltip.style.top = `${y + 4}px`;
    }

    function stackedLink(d) {
      // Custom path that keeps midpoints separated to reduce overlap
      const x0 = d.source.x1;
      const x1 = d.target.x0;
      const y0 = d.y0;
      const y1 = d.y1;
      const xi = d3.interpolateNumber(x0, x1);
      const xA = xi(0.25);
      const xB = xi(0.75);
      return `M${x0},${y0}C${xA},${y0} ${xB},${y1} ${x1},${y1}`;
    }

    function hideTooltip() {
      tooltip.style.opacity = 0;
      tooltip.style.transform = 'translateY(-6px)';
    }

    function showError(err) {
      console.error(err);
      statusEl.textContent = err.message || 'Failed to render.';
      setPlaceholder('Unable to render chart. Please use “Load another file” or serve this directory (e.g. `python -m http.server 8000`).');
    }

    function setPlaceholder(text) {
      if (!placeholder) return;
      placeholder.textContent = text;
      placeholder.style.display = text ? 'flex' : 'none';
    }

    window.addEventListener('resize', () => {
      if (window.__lastSankeyData) drawChart(window.__lastSankeyData);
    });

    const restored = tryRestoreUserState();
    if (!restored) {
      loadDefaultWorkbook();
    }
  </script>
</body>
</html>
